use std::sync::Arc;

use tokio::sync::RwLock;
use tonic::{async_trait, Request, Response as TonicResponse, Status};
use tower_http::request_id::RequestId;
use tracing::{error, info};

use crate::{
    config::PermissionsConfig,
    http::controler::kratos_controler,
    permission::{iam_server::Iam, Input, Reply},
};

///structure representin the router, it implements the trait PermissionSrv
///wich is generated by tonic-build, the member function represente the diferente route
pub struct MyIam {
    pub config: Arc<RwLock<PermissionsConfig>>,
}

#[async_trait]
impl Iam for MyIam {
    ///grpc route to add an identity field
    async fn add_permission(&self, req: Request<Input>) -> Result<TonicResponse<Reply>, Status> {
        let (_, ext, payload) = req.into_parts();
        let uuid = match ext.get::<RequestId>() {
            Some(uuid) => uuid
                .header_value()
                .to_str()
                .expect("the uuid should be a valide string"),
            None => return Err(Status::internal("No uuid is assigned to this request!")),
        };
        info!("{uuid}: adding data to identity");
        let config = self.config.read().await;
        let client = match &config.kratos.client {
            Some(client) => client,
            None => {
                return Err(Status::internal(format!(
                    "{uuid}: Kratos client not initialized"
                )))
            }
        };
        let resp = kratos_controler(client, uuid, payload, "add").await;
        if let Err(e) = resp {
            error!("failed to apply patch: {e}");
            return Err(Status::internal(e.to_string()));
        }
        Ok(TonicResponse::new(Reply {}))
    }

    ///grpc route to remove an identity field
    async fn remove_permission(&self, req: Request<Input>) -> Result<TonicResponse<Reply>, Status> {
        let (_, ext, payload) = req.into_parts();
        let uuid = match ext.get::<RequestId>() {
            Some(uuid) => uuid
                .header_value()
                .to_str()
                .expect("the uuid should be a valide string"),
            None => return Err(Status::internal("No uuid is assigned to this request!")),
        };
        info!("{uuid}: removing data to identity");
        let config = self.config.read().await;
        let client = match &config.kratos.client {
            Some(client) => client,
            None => {
                return Err(Status::internal(format!(
                    "{uuid}: Kratos client not initialized"
                )))
            }
        };
        let resp = kratos_controler(client, uuid, payload, "remove").await;
        if let Err(e) = resp {
            return Err(Status::internal(e.to_string()));
        }
        Ok(TonicResponse::new(Reply {}))
    }

    ///grpc route to replace an identity field
    async fn replace_permission(
        &self,
        req: Request<Input>,
    ) -> Result<TonicResponse<Reply>, Status> {
        let (_, ext, payload) = req.into_parts();
        let uuid = match ext.get::<RequestId>() {
            Some(uuid) => uuid
                .header_value()
                .to_str()
                .expect("the uuid should be a valide string"),
            None => return Err(Status::internal("No uuid is assigned to this request!")),
        };
        info!("{uuid}: replacing data in identity");
        let config = self.config.read().await;
        let client = match &config.kratos.client {
            Some(client) => client,
            None => {
                return Err(Status::internal(format!(
                    "{uuid}: Kratos client not initialized"
                )))
            }
        };
        let resp = kratos_controler(client, uuid, payload, "replace").await;
        if let Err(e) = resp {
            return Err(Status::internal(e.to_string()));
        }
        Ok(TonicResponse::new(Reply {}))
    }
}
