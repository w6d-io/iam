use std::sync::Arc;

use tokio::sync::RwLock;
use tonic::{async_trait, Request, Response as TonicResponse, Status};
use tower_http::request_id::RequestId;
use tracing::{error, info};

use crate::{
    config::IamConfig,
    http::controler::kratos,
    permission::{iam_server::Iam, Input, Reply},
};

///Representation of the router, it implements the trait `PermissionSrv`
///wich is generated by tonic-build, the member function represente the diferente route.
pub struct MyIam {
    pub config: Arc<RwLock<IamConfig>>,
}

#[async_trait]
impl Iam for MyIam {
    ///Grpc route to add an identity field.
    async fn add_permission(&self, req: Request<Input>) -> Result<TonicResponse<Reply>, Status> {
        let (_, ext, payload) = req.into_parts();
        let uuid = match ext.get::<RequestId>() {
            Some(uuid) => uuid
                .header_value()
                .to_str()
                .expect("the uuid should be a valide string"),
            None => return Err(Status::internal("No uuid is assigned to this request!")),
        };
        info!("{uuid}: adding data to identity");
        let config = self.config.read().await;
        let Some(client) = &config.kratos.client else {
            return Err(Status::internal(format!(
                "{uuid}: Kratos client not initialized"
            )));
        };
        let resp = kratos(client, uuid, payload, "add").await;
        if let Err(e) = resp {
            error!("failed to apply patch: {e}");
            return Err(Status::internal(e.to_string()));
        }
        Ok(TonicResponse::new(Reply {}))
    }

    ///Grpc route to remove an identity field.
    async fn remove_permission(&self, req: Request<Input>) -> Result<TonicResponse<Reply>, Status> {
        let (_, ext, payload) = req.into_parts();
        let uuid = match ext.get::<RequestId>() {
            Some(uuid) => uuid
                .header_value()
                .to_str()
                .expect("the uuid should be a valide string"),
            None => return Err(Status::internal("No uuid is assigned to this request!")),
        };
        info!("{uuid}: removing data to identity");
        let config = self.config.read().await;
        let Some(client) = &config.kratos.client else {
            return Err(Status::internal(format!(
                "{uuid}: Kratos client not initialized"
            )));
        };
        let resp = kratos(client, uuid, payload, "remove").await;
        if let Err(e) = resp {
            return Err(Status::internal(e.to_string()));
        }
        Ok(TonicResponse::new(Reply {}))
    }

    ///Grpc route to replace an identity field.
    async fn replace_permission(
        &self,
        req: Request<Input>,
    ) -> Result<TonicResponse<Reply>, Status> {
        let (_, ext, payload) = req.into_parts();
        let uuid = match ext.get::<RequestId>() {
            Some(uuid) => uuid
                .header_value()
                .to_str()
                .expect("the uuid should be a valide string"),
            None => return Err(Status::internal("No uuid is assigned to this request!")),
        };
        info!("{uuid}: replacing data in identity");
        let config = self.config.read().await;
        let Some(client) = &config.kratos.client else {
            return Err(Status::internal(format!(
                "{uuid}: Kratos client not initialized"
            )));
        };
        let resp = kratos(client, uuid, payload, "replace").await;
        if let Err(e) = resp {
            return Err(Status::internal(e.to_string()));
        }
        Ok(TonicResponse::new(Reply {}))
    }
}
